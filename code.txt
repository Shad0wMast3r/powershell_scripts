#Requires -RunAsAdministrator
<#
Written By Andy 'shadowMast3r' Kukuc
Follow me on Github
This is an ultimate script that I decided to over engineer and over complicate
#>
Clear-History;
Clear-Host;
$user_input_valid = @(1..9);
$last_reboot=Get-WmiObject -class Win32_OperatingSystem | Select-Object @{LABEL='LastBootUpTime'; EXPRESSION={$_.ConvertToDateTime($_.lastbootuptime)}};
$last_reboot=$last_reboot -replace '[@,{,LastBootUpTime,},=]',"";
While (($user_input = Read-Host -Prompt "Please enter a selection`n1. Check Hard Drives`n2. Check Event Viewer`n3. Windows Updates`n4. Reset User Password`n5. Grab USB Device History`n6. Uninstall Software`n7. Delete IIS Log Files Older Than 60 Days`n8. List of old AD Users`n9. Exit`n") -notmatch $user_input_valid) {
    #Lets get the hostname to avoid confusion down the line and the operating system.
    Write-Host 'Computer Name:'(Get-WmiObject -class Win32_OperatingSystem).CSName`
    "`nOperating System:"(Get-WmiObject -class Win32_OperatingSystem).Caption`
    "`nWindows Version Number:"(Get-WmiObject -class Win32_OperatingSystem).Version`
    "`nWindows Build Number:"(Get-WmiObject -class Win32_OperatingSystem).BuildNumber;
    Write-Host "Last Reboot:"($last_reboot)"`n";  
    #Lets add switch case because why not
    Switch ($user_input) {
        1 {
            <#Beginning of the Hard Drive Switch Statement#>
            $drives = get-wmiobject win32_logicaldisk -filter "drivetype=3" | select-object -expandproperty name;
            #The script will remove the semi colons since the next variable that I wrote will be using strings.
            $drive_information = @(
                'DriveLetter'
                'HealthStatus'
                'OperationalStatus'
                @{Name = 'Size'; Expression = { "{0:N2} GB" -f ($_.Size / 1GB) } } #Size of the drive
                @{Name = 'SizeRemaining'; Expression = { "{0:N2} GB" -f ($_.SizeRemaining / 1GB); } } #Remaining free size.
                @{Name = 'Total Used Space Percentage'; Expression = { "{0:N1}%" -f (($_.Size - $_.SizeRemaining) / $_.Size * 100) } }) #Determines percentage used up.)#End of the Method for Variable $drive_information
            #Now the command to format everything and give us the details we want
            Write-Host "The current drives are $drives";
            $drives = $drives -replace '[:]', "";
            Get-Volume $drives | Select-Object $drive_information | Format-List;
        } <#End of the Hard Drive Switch Statement Whatever I don't care#>

        2 {
            <#Beginning of Event Viewer Switch#>
            #First things first were going to import the entire event viewer into something.
            $first_of_the_month = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
            $first_of_the_month_converted = [System.Management.ManagementDateTimeConverter]::ToDMTFDateTime(($first_of_the_month)); #grab current time and set it to the beginning of the month
            Write-Host("The script will now scan Event Log from $first_of_the_month to " + (Get-Date) + ".`nThe Following Logs will be checked for any unusual ids. `n[#] Application [#]`n[#] System [#]");
            $read_me = Read-Host("Please enter the type of ID Number you would like to see.`n1. Critical`n2. Error`n");
            $valid_input = @(1, 2);
            if ($read_me -eq $valid_input[0]) {
                Write-Host("Displaying Only Critical Event IDs.`nPlease Wait...") -ForegroundColor "Red"
                $query_windowsnt32_eventlog = "Select * From win32_ntlogevent where (Type='Critical') And (logfile='Application' or logfile='System') and TimeGenerated > '$first_of_the_month_converted'" + "and Message != null";
                Get-WmiObject -Query $query_windowsnt32_eventlog | Select-Object @{name = "TimeGenerated"; expression = { $_.ConvertToDateTime($_.TimeGenerated) } }, LogFile, EventCode, Type, Message;

            }
            elseif ($read_me -eq $valid_input[1]) {
                Write-Host("Displaying Only Error Event IDs.`nPlease Wait...") -ForegroundColor "Yellow"
                $query_windowsnt32_eventlog = "Select * From win32_ntlogevent where (Type='Error') And (logfile='Application' or logfile='System')  and TimeGenerated > '$first_of_the_month_converted'" + "and Message != null";
                Get-WmiObject -Query $query_windowsnt32_eventlog | Select-Object @{name = "TimeGenerated"; expression = { $_.ConvertToDateTime($_.TimeGenerated) } }, LogFile, EventCode, Type, Message;
            }
            else { Write-Host("Invalid Input. Please Try Again!"); }
        }<#End of Event Viewer Switch#>
        
        3 {
            <#Beginning of Windows Update Switch
            This part of the code will do some windows update checks. Check if there are any existing updates that need to be installed.
            First things first lets go ahead and grab the currently installed Windows Updates!#>
            Write-Host("Returning current installed Windows Updates`n");
            get-wmiobject -class win32_quickfixengineering | Format-Table -Auto
            
            Write-Host("`n[*] DISCLAIMER: The retrieved list of updates are monitored by Continuum. [*]`nThese updates will be automatically installed when Continuum has completed verification that the updates will not corrupt the Continuum Software!`nIf you proceed with installation of the Windows Updates there is a chance that the Continuum Software will no longer work and might have to be reinstalled!");
            $windows_updates_confirmation = Read-Host("[+] If you just want to see the pending updates but do not want to install then select Y. [+]`nY or N");
            if ($windows_updates_confirmation -match "[y/Y]") {
                Write-Host("`nRetrieving Pending Windows Updates.`n");
                $WindowsUpdate = New-Object -ComObject Microsoft.Update.Session;
                $findupdates = $windowsupdate.CreateUpdateSearcher();
                $updates = @($findupdates.Search("IsHidden=0 and IsInstalled=0").Updates);
                $updates | Select-Object Title | Format-List;
            }
            elseif ($windows_updates_confirmation -match "[n/N]") {
                Clear-Host; 
                Write-Host("Returning to Main Menu!");
            }
            else {
                Clear-Host;
                Write-Host("Invalid Input Please Try Again!");
            }
        }<#End of Windows Update Switch#>
        4 {
            <#Reset Active Directory Users password#>
            Import-Module ActiveDirectory #Import here not above keep it in the case 
            #Prompt for temporary password or set new_password
            $active_directory_input = Read-Host("Please select if you want to generate a temporary password and give to the user or set a password per users request`n1.Temporary Password`n2.Set Password");
            #Milo Bradshaw told me about this and I think this is genius
            if ($active_directory_input -match 1) {
                Add-Type -AssemblyName System.web;
                $new_password = [System.Web.Security.Membership]::GeneratePassword(12, 3);
                Write-Host("[*] New Temporary Password: " + $new_password + " [*]`n"); <#Debugging#>
                $active_directory_username = Read-Host("Please enter the username: ");
                Set-ADAccountPassword $active_directory_username -NewPassword (ConvertTo-SecureString -ASPlainText $new_password -Force -Reset -Verbose) -Passthru | Set-ADUser -ChangePasswordAtLogon $True | Unlock-AdAccount -Identity $active_directory_username;
                Write-Host($active_directory_username + " password has been reset!`n" + $active_directory_username + " can change their password when they logon!`nThe account has also been unlocked!");
                Write-Host("Syncing The Domain to push the new password.");
                repadmin /Syncall /APed;
                Write-Host("Sync Complete!");
            }
            elseif ($active_directory_input -match 2) {
                $set_password = Read-Host("Please enter the set password from the user: ");
                $convert_set_password = ConvertTo-SecureString($set_password) -AsPlainText -Force;
                $active_directory_username = Read-Host("Please enter the username: ");
                Set-ADAccountPassword $active_directory_username -NewPassword $convert_set_password -Reset;
                Write-Host($active_directory_username + " password has been reset!`nThe account is also unlocked!");
                Write-Host("Syncing The Domain to push the new password.");
                repadmin /Syncall /APed;
                Write-Host("Sync Complete!");
                <#When more time add a fucken if else or while loop to check if the account is locked as well!#>
            }
            else { Write-Host("Invalid Selection! Please try again!") }

        }<#End of Active Directory Users Case#>
        5 {
            <#Start of USB Device History Switch
            Get Recently Plugged in USB Devices#>
            Write-Host("[*] Gathering previously connected USB devices... [*]");
            Get-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Enum\USBSTOR\*\*' | Select-Object FriendlyName | Format-Table
            
        }<#End of USB Device History Switch#>
        6 { #Fix this
            <#Uninstall Software Switch#>
            Write-Host("[*] Gathering a list of currently installed software on the machine... [*]");
            $software_array=Get-WmiObject -Class Win32_Product -Property Name | Select -Expand Name;
            Write-Host($software_array)
            #foreach($program in $software_array){
                #write-Host("[*]$program")
                https://xkln.net/blog/please-stop-using-win32product-to-find-installed-software-alternatives-inside/
            #}
            
        }<#End of Uninstall Software Switch#>
        7 {
            #Delete files older than a set ammount days. IIS Log Files on Exchange Server.
            Write-Host("The script will delete IIS log files for the set day you specified.`n");
            $days = Read-Host("Please specifiy the days you would like all the files to be deleted from. (ex 30 days, 60 days, 90 days)`nThe max is 365 days (1 year)") -is [int] ;
            if ($days -le 365) {
                Write-Host("Clearing IIS logs from $days ago");
                Get-ChildItem 'C:\inetpub\logs\LogFiles\W3SVC1', 'C:\inetpub\logs\LogFiles\W3SVC2' | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays($days) } | Remove-Item;   
            }
            elseif ($days -gt 365) {
                Write-Host("Number is bigger then 365 please try again");
            }
            else{
                Write-Host("Invalid Selection Please Try Again!");
            }
            #Get-ChildItem 'C:\inetpub\logs\LogFiles\W3SVC1', 'C:\inetpub\logs\LogFiles\W3SVC2' | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-60) } | Remove-Item;   
        }<#End of delete files older than 60 days.#>
        8{<#Print out a list of AD Users that have not been active for 90 days or more.#>
        Write-Host("The script will now output a .csv file that contains all users that have not signed in 90 days or more.")
        #First checks to make sure the module AD-User exists on the system.
        if (Get-Command "Get-ADUser"-erroraction SilentlyContinue){
                Write-Host("Get-ADUser exists on the system. The script will now run!");
                Get-ADUser -Filter * -Properties LastLogonDate | Where-Object {$_.LastLogonDate -lt (Get-Date).AddDays(-90)};

        }
        else {
            write-host("Get-ADUser does not exist on the system.`n Are you on the domain controller server?");
        }
        }
        9 {
            Write-Host("Thank You For Using My Script!`nHave a Nice Day!");
            Clear-Host;
            Clear-History;
            exit;
        }
        Default {
            Write-Host("Invalid Selection! Please Try Again!");
        }<#End of default case#> 
    }<#End of SWITCH CASE#>
}<#End of WHILE LOOP#>